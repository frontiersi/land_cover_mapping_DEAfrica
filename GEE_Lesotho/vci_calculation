// Import external dependencies
var palettes = require('users/gena/packages:palettes');
var wrapper = require('users/adugnagirma/gee_s1_ard:wrapper');
var S2Masks = require('users/ocsgeospatial/functions:s2_masks.js');
var composites = require('users/ocsgeospatial/functions:composites.js');

// Import the Dynamic Time Warping script
var DTW = require('users/ocsgeospatial/functions:dtw.js');

// Input data parameters
var CLASS_NAME = 'LC_Class_I'; // Property name of the feature collection containing the crop type class attribute
var AGG_INTERVAL = 60; // Number of days to use to create the temporal composite for 2020
var TIMESERIES_LEN = 6; // Number of timestamps in the time series
var PATTERNS_LEN = 6; // Number of timestamps for the reference data points
var CLASS_NO = 12; // Number of classes to map. Those are: builtup, water, trees, baresoil, cropland, rangeland, wetland
var S2_BAND_LIST = ['B2', 'B3', 'B11', 'B12', 'ndvi', 'ndci']; // S2 Bands to use as DTW input
var S1_BAND_LIST = ['VV', 'VH']; // S1 Bands to use as DTW input
var BAND_NO = S1_BAND_LIST.concat(S2_BAND_LIST).length; // Number of bands to use for the DTW. Currently,
                 // The default 7 bands are: S2 NDVI, S2 B2, S2 B3, S2 B11, S2 B12, S1 VV, S1 VH
var DOY_BAND = 'doy'; // Name of the Day of Year band for the time-aware DTW implementation

// DTW time parameters
var BETA = 50; // Beta parameter for the Time-Weighted DTW, controlling the tolerance (in days) of the weighting.
var ALPHA = 0.1; // ALPHA parameter for the Time-Weighted DTW, controlling steepness of the logistic distribution

// Import external water mask dataset
var not_water = ee.Image("JRC/GSW1_2/GlobalSurfaceWater").select('max_extent').eq(0); // JRC Global Surface Water mask

// Import ALOS AW3D30 latest DEM version v3.2
var dem = ee.ImageCollection("JAXA/ALOS/AW3D30/V3_2").select("DSM");
dem = dem.mosaic().setDefaultProjection(dem.first().select(0).projection());

//Remove mountain areas that are not suitable for crop growth
var slope = ee.Terrain.slope(dem); // Calculate slope from the DEM data
var dem_mask = dem.lt(3600); // Mask elevation above 3600m, where no crops grow.
var slope_mask = slope.lt(30); // Mask slopes steeper than 30Â°, where no crops grow.
var crop_mask = dem_mask.and(slope_mask); // Combine the two conditions

// Function to calculate the NDVI for planet mosaics
var addNDVI = function(img){
  return img.addBands(img.normalizedDifference(['B8','B4']).multiply(10000).toInt16().rename('ndvi'));
};

var addNDCI = function(img){
  return img.addBands(img.normalizedDifference(['B5','B4']).multiply(10000).toInt16().rename('ndci'));
};

// Define the are of interest to use
var adm0_name = 'Lesotho';

// A dictionary that will be iterated over for multi-year land cover mapping.
// Comment out the years you do not wish to produce.
var year_dict = {'2021': 'COPERNICUS/S2_SR',
                 //'2020': 'COPERNICUS/S2_SR',
                 //'2019': 'COPERNICUS/S2',
                 //'2018': 'COPERNICUS/S2',
                 //'2017': 'COPERNICUS/S2'
                };

// Ensure that the retrieved county geometry is unique
var county = ee.FeatureCollection("FAO/GAUL/2015/level0")
             .filter(ee.Filter.equals('ADM0_NAME', 'Rwanda'));
             
var protected_areas = ee.FeatureCollection("WCMC/WDPA/current/polygons").filterBounds(county.geometry());

Export.table.toDrive({
  collection: protected_areas
})

// Center map on the county and plot it on the map
Map.centerObject(county.geometry());
Map.layers().reset([ui.Map.Layer(county, {}, adm0_name)]);

// Function that performs DTW land classification for a given year.
var RFClassification = function(year, collection_type){

  var date_range = ee.Dictionary({'start': '2017-01-01', 'end': year + '-10-01'}); // Second half of year used only.
  // Load the Sentinel-2 collection for the time period and area requested
  var s2_cl = S2Masks.loadImageCollection(collection_type, date_range, county.geometry());

  // Perform cloud masking using the S2 cloud probabilities assets from s2cloudless,
  // courtesy of Sentinelhub/EU/Copernicus/ESA
  var masked_collection = s2_cl
                          .filterDate(date_range.get('start'), date_range.get('end'))
                          .map(S2Masks.addCloudShadowMask(not_water, 1e4))
                          .map(S2Masks.applyCloudShadowMask)
                          .map(addNDVI)
                          .map(addNDCI); // Add NDVI to band list

  // Generate a list of time intervals for which to generate a harmonized time series
  var time_intervals = composites.extractTimeRanges(date_range.get('start'), date_range.get('end'), 30);
  
  // Generate harmonized monthly time series of FCover as input to the vegetation factor V
  var s2_ts = composites.harmonizedTS(masked_collection, S2_BAND_LIST, time_intervals, {agg_type: 'geomedian'});

  // Replace masked pixels by the mean of the previous and next timestamps
  // And add a Day of Year (DOY) band
  // This is the linear interpolation approach,
  // which is more lightweight than other gap-filling approaches like Savitzky-Golay or harmonic regression
  var s2_stack = ee.Image(s2_ts
                          .map(function(image){
                            var currentDate = ee.Date(image.get('system:time_start'));
                            var meanImage = s2_ts.filterDate(currentDate.advance(-AGG_INTERVAL-1, 'day'),
                                                                 currentDate.advance(AGG_INTERVAL+1, 'day')).mean();
                            // replace all masked values
                            var ddiff = currentDate.difference(ee.Date(ee.String(date_range.get('start'))), 'day');
                            return meanImage.where(image, image)
                                   //.addBands(ee.Image(ddiff).rename(DOY_BAND).toInt16());
                          })
                          .iterate(function(image, previous){return ee.Image(previous).addBands(image)}, ee.Image([])));

  // Define S1 preprocessing parameters, as per:
  // Version: v1.2
  // Date: 2021-03-10
  // Authors: Mullissa A., Vollrath A., Braun, C., Slagter B., Balling J., Gou Y., Gorelick N.,  Reiche J.
  // Sentinel-1 SAR Backscatter Analysis Ready Data Preparation in Google Earth Engine. Remote Sensing 13.10 (2021): 1954.
  // Description: This script creates an analysis ready S1 image collection.
  // License: This code is distributed under the MIT License.
  var parameter = {//1. Data Selection
                   START_DATE: date_range.get('start'),
                   STOP_DATE: date_range.get('end'),
                   POLARIZATION:'VVVH', // The polarization available may differ depending on where you are on the globe
                   ORBIT : 'ASCENDING', // The orbit availability may differ depending on where you are on the globe
                   // Check out this page to find out what parameters suit your area:
                   // https://sentinels.copernicus.eu/web/sentinel/missions/sentinel-1/observation-scenario
                   GEOMETRY: county.geometry(),
                   //2. Additional Border noise correction
                   APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION: true,
                   //3.Speckle filter
                   APPLY_SPECKLE_FILTERING: true,
                   SPECKLE_FILTER_FRAMEWORK: 'MULTI',
                   SPECKLE_FILTER: 'LEE',
                   SPECKLE_FILTER_KERNEL_SIZE: 9,
                   SPECKLE_FILTER_NR_OF_IMAGES: 10,
                   //4. Radiometric terrain normalization
                   APPLY_TERRAIN_FLATTENING: true,
                   DEM: dem,
                   TERRAIN_FLATTENING_MODEL: 'VOLUME', // More desirable for vegetation monitoring.
                                                       //Use "SURFACE" if working on urban or bare soil applications
                   TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER: 0,
                   //5. Output
                   FORMAT : 'DB',
                   CLIP_TO_ROI: false,
                   SAVE_ASSETS: false
  }

  //Preprocess the S1 collection
  var s1_ts = wrapper.s1_preproc(parameter)[1]
              .map(function(image){return image.multiply(1e4).toInt16() // Convert to Int16 using 10000 scaling factor
                                          .set({'system:time_start': image.get('system:time_start')})});

  // Create equally-spaced temporal composites covering the date range and convert to multi-band image
  var s1_stack = ee.Image(composites.harmonizedTS(s1_ts, S1_BAND_LIST, time_intervals, {agg_type: 'geomedian'})
                          .iterate(function(image, previous){return ee.Image(previous).addBands(image)}, ee.Image([])));

  // Re-order the stack order before converting it to a DTW-ready input array
  var s1s2_stack = s1_stack.addBands(s2_stack)
                   .select(ee.List(S1_BAND_LIST.concat(S2_BAND_LIST))
                   //.add(DOY_BAND) // Make sure DOY band goes last
                   .map(function(band){return ee.String(band).cat('.*')})) // Add regex for band selection
                   .unmask(0) // DTW does not tolerate null values, so gap fill to 0 if gaps remain
                   .clip(county.geometry()); // Clip again to remask unmasked values outside of area of interest
  
  return s2_ts
};

var s2_composites = RFClassification('2021', 'COPERNICUS/S2_SR');

var s2_hist = ee.ImageCollection.fromImages([s2_composites.filterDate('2017-01-01', '2017-12-30').max(),
                                        s2_composites.filterDate('2018-01-01', '2018-12-30').max(),
                                        s2_composites.filterDate('2020-01-01', '2020-12-30').max()]);
var s2_vci = s2_composites.select('ndvi').filterDate('2021-01-01', '2021-12-30').max().subtract(s2_hist.select('ndvi').min())
                          .divide(s2_hist.select('ndvi').max().subtract(s2_hist.select('ndvi').min())).multiply(100);

var s2_ndci = s2_composites.select('ndci').filterDate('2021-07-01', '2021-09-30').median().subtract(s2_hist.select('ndci').min())
                      .divide(s2_hist.select('ndci').max().subtract(s2_hist.select('ndci').min())).multiply(100);

var palettes = require('users/gena/packages:palettes');
var palette = palettes.colorbrewer.RdYlGn[9];

Map.centerObject(county);
Map.addLayer(s2_vci.clip(county.geometry()).updateMask(not_water), {palette: palette, min: -50, max:150}, 'VCI');
Map.addLayer(s2_ndci.clip(county.geometry()).updateMask(not_water.not()), {palette: palette.reverse(), min: -50, max: 100}, 'NDCI');

Export.image.toDrive({
  image: s2_vci.clip(county.geometry()).updateMask(not_water).toByte(),
  scale: 10,
  crs: 'EPSG:4326',
  //assetId: 'users/soilwatch/Sudan/temp_indicators/ndvi',
  maxPixels: 1e13,
  description: 'vci',
  region: county.geometry(),
  fileFormat:'GeoTIFF',
  formatOptions: {
    cloudOptimized: true
  }
});

Export.image.toDrive({
  image: s2_ndci.clip(county.geometry()).updateMask(not_water.not()),
  scale: 10,
  crs: 'EPSG:4326',
  //assetId: 'users/soilwatch/Sudan/temp_indicators/ndvi',
  maxPixels: 1e13,
  description: 'ndci',
  region: county.geometry(),
  fileFormat:'GeoTIFF',
  formatOptions: {
    cloudOptimized: true
  }
});
                                        