// ****************************************************************************************************************** //
// ******************************** 3. Land Cover Harmonization Workbench - Lesotho ********************************* //
// ****************************************************************************************************************** //
// This workbench performs the land cover harmonization across the produced land cover years

// ****************************************************************************************************************** //
var VERSION_NO = 'v3'; // Version number of the land cover outputs produced
var ALGO = 'RF'; // Algorithm to apply. Default is Random Forest, as sufficient training data is available for 2021.

var lcdb2017 = ee.Image('users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_2017_'+VERSION_NO);
var lcdb2018 = ee.Image('users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_2018_'+VERSION_NO);
var lcdb2019 = ee.Image('users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_2019_'+VERSION_NO);
var lcdb2020 = ee.Image('users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_2020_'+VERSION_NO);
var lcdb2021 = ee.Image('users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_2021_'+VERSION_NO);

// Initialize the years backwards, because we take 2021 to be the baseline year
var lc_timeseries = [lcdb2021, lcdb2021, lcdb2020, lcdb2019, lcdb2018, lcdb2017, lcdb2017];
// Buffer the list with double the year 2021 and double the year 2017 so all years have a previous and a next neighbour
var years = ['2021', '2021', '2020', '2019', '2018', '2017', '2017'];
// ****************************************************************************************************************** //

var lcdb2015 = ee.Image('users/ocsgeospatial/Lesotho/LCDB_Lesotho_v2_2')
               .remap([11, 12, 21, 22, 23, 24, 31, 33, 41, 42, 43, 44, 51, 61, 62, 71, 72, 73, 74, 75, 13, 14, 25, 32, 34, 35, 36, 37, 52], 
                      [1, 1, 2, 2, 3, 14, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 12, 12, 15, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0]).selfMask();

var county = ee.Feature(ee.FeatureCollection("users/ocsgeospatial/Lesotho/lesotho_boundaries").first()).simplify(100);

/*
var palette = [
  '#ea3f42', // 1.urban
  '#fbd278', // 2.croplands
  '#fbd278', // 3. degraded crop
  '#527300', // 4. needleleaf
  '#527300', // 5. broadleaf
  '#164fab', // 6. water
  '#7db4ff', // 7. wetlands
  '#164fab',  // 8. river banks
  '#a4e400', // 9. shrub
  '#d8febc',  // 10. grass
  '#d8febc', //11. degraded grass
  '#fffebb', // 12. barren
  '#fffebb', // 13. mine
  '#95dfa5', // 14. Irrigated Cropland
  //'#a4651d' // 15. Gullies
];
*/

// The corresponding color hex keys for the land cover classes
var palette = [
  '#ff1411', // 1.urban
  '#fff78f', // 2.croplands
  '#fbd278', // 3. degraded crop
  '#4e8845', // 4. needleleaf
  '#527300', // 5. broadleaf
  '#005b85', // 6. water
  '#68b6e5', // 7. wetlands
  '#164fab',  // 8. river banks
  '#c78d36', // 9. shrub
  '#d6e591',  // 10. grass
  '#d8febc', //11. degraded grass
  '#9ba7a0', // 12. barren
  '#fffebb', // 13. mine
  '#95dfa5', // 14. Irrigated Cropland
  '#562118' // 15. Gullies
];

// The 2015 palette has additional classes from the newly classified data
var palette2015 = [
  '#ea3f42', // 1.urban
  '#fbd278', // 2.croplands
  '#fbd278', // 3. degraded crop
  '#527300', // 4. needleleaf
  '#527300', // 5. broadleaf
  '#164fab', // 6. water
  '#7db4ff', // 7. wetlands
  '#164fab',  // 8. river banks
  '#a4e400', // 9. shrub
  '#d8febc',  // 10. grass
  '#d8febc', //11. degraded grass
  '#fffebb', // 12. barren
  '#fffebb', // 13. mine
  '#95dfa5', // 14. Irrigated Cropland
  '#a4651d' // 15. Gullies
];

// Plot the original Land Cover Series
//Map.addLayer(lcdb2015, {palette: palette2015, min: 1, max: 15}, 'lcdb2015');
Map.centerObject(lcdb2017);
Map.addLayer(lcdb2017, {palette: palette, min: 1, max: 14}, '2017');
Map.addLayer(lcdb2018, {palette: palette, min: 1, max: 14}, '2018');
Map.addLayer(lcdb2019, {palette: palette, min: 1, max: 14}, '2019');
Map.addLayer(lcdb2020, {palette: palette, min: 1, max: 14}, '2020');
Map.addLayer(lcdb2021, {palette: palette, min: 1, max: 14}, '2021');

var previous;
var current;
var next;
var lc_timeseries_new = [];
for (var i = 1; i < lc_timeseries.length-1; i++) {
  
  // Define a previous and next year by selecting the adjacent years wrt the current year
  next = ee.Image(lc_timeseries[i-1]).unmask(0);
  current = ee.Image(lc_timeseries[i]).unmask(0);
  previous = ee.Image(lc_timeseries[i+1]).unmask(0);
  
  // Apply the land cover transition rules
  lc_timeseries[i] =  current
                      .where(previous.eq(1).and(current.neq(1)).and(next.eq(1)) // Avoid spurious change of built-up
                             .or(next.eq(1).and(current.eq(6).or(current.eq(7)))) // Avoid unlikely change from water/wetland to built-up
                             , 1)
                      .where(previous.eq(2).and(current.neq(2)).and(next.eq(2)) // Avoid spurious change of cropland, 
                                                                                // assuming 1-year fallow to be highly unlikely
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                             .or(next.eq(2).and(current.eq(12))) // Avoid unlikely change from bare soil to cropland,
                                                                 // assuming bare soil is either too degraded or rocky to support growth
                             , 2)
                      .where(previous.eq(4).and(current.neq(4)).and(next.eq(4)) // Avoid spurious change of forest
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                             // Avoid unlikely change from any class to forest except water, shrubland or wetland
                             .or(next.eq(4).and(current.neq(6).and(current.neq(9)).and(current.neq(7)))) 
                             , 4)
                      .where(next.eq(6).and(current.eq(1)), 6) // Avoid unlikely change from built-up to water
                      .where(previous.eq(7).and(current.neq(7)).and(next.eq(7)) // Avoid spurious change of wetland
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                             // Avoid unlikely change from any class to wetland except water, grassland, shrubland or cropland
                             .or(next.eq(7).and(current.neq(6).and(current.neq(10)).and(current.neq(9)).and(current.neq(2)))) 
                             , 7)
                      .where(previous.eq(9).and(current.neq(9)).and(next.eq(9)) // Avoid spurious change of shrubland
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                             // Avoid unlikely change from any class to shrubland except water, wetland, grassland and forest
                            .or(next.eq(9).and(current.neq(6).and(current.neq(7)).and(current.neq(10)).and(current.neq(4))))
                            , 9)
                      .where(previous.eq(10).and(current.neq(10)).and(next.eq(10)) // Avoid spurious change of grassland
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                             // Avoid unlikely change from any class to grassland except water, bare soil, cropland, shrubland and wetland
                             .or(next.eq(10).and(current.neq(6).and(current.neq(12)).and(current.neq(2)).and(current.neq(9)).and(current.neq(7))))
                             , 10)
                      .where(previous.eq(12).and(current.neq(12)).and(next.eq(12)) // Avoid spurious change of bare soil
                             .and(current.neq(6)) // Except if it is water (dam water levels)
                            .or(next.eq(12).and(current.eq(1))) // Avoid unlikely change from built-up to bare soil,
                                                                // due to spectral similarity between the two classes
                            , 12) 
                      .where(current.eq(0), next) // In case there are remaining 0-value pixels
                      .selfMask();
  
  // For the edge case years, an additional double-year is applied, to ensure continuity and logicity in the land cover transitions
  // Although some of these transitions are plausible, for lack of knowing the previous (i.e 2016) and subsequent (i.e. 2022), 
  // we need to come up with ways to avoid having spurious changes occuring too much, which this double-year check ensures
  if (i === 1) {
    lc_timeseries[i] = lc_timeseries[i].where(lc_timeseries[i].eq(9).and(previous.eq(4)).and(lc_timeseries[i+2].eq(4))
                                              , 4) // Shrubland to forest conversion if past two years were forest
                                       .where(lc_timeseries[i].eq(2).and(previous.eq(10)).and(lc_timeseries[i+2].eq(10))
                                              , 10) // Cropland to grassland in case previous two years were grassland
                                       .where(lc_timeseries[i].eq(7).and(previous.eq(10)).and(lc_timeseries[i+2].eq(10))
                                              , 10) // Wetland to grassland in case previous two years were grassland
                                       .where(lc_timeseries[i].eq(4).and(previous.eq(7)).and(lc_timeseries[i+2].eq(7))
                                              , 7) // Forest to Wetland in case previous two years were wetland
                                       .where(lc_timeseries[i].eq(9).and(previous.eq(10)).and(lc_timeseries[i+2].eq(10))
                                              , 10) // Shrubland to grassland in case previous two years were grassland
                                       .where(lc_timeseries[i].eq(1).and(previous.eq(10)).and(lc_timeseries[i+2].eq(10))
                                              , 10) // Built-up to grassland in case previous two years were grassland
                                       .where(lc_timeseries[i].eq(1).and(previous.eq(2)).and(lc_timeseries[i+2].eq(2))
                                              , 2) // Built-up to cropland in case previous two years were cropland
                                       .where(lc_timeseries[i].eq(10).and(previous.eq(2)).and(lc_timeseries[i+2].eq(2))
                                              , 2) // Grassland to cropland in case previous two years were cropland;
                                       .where(lc_timeseries[i].eq(10).and(previous.eq(9)).and(lc_timeseries[i+2].eq(9))
                                             , 9) // Grassland to shrubland in case the previous two years were shrubland
  }

  if (i === lc_timeseries.length-2) {
    lc_timeseries[i] = lc_timeseries[i].where(lc_timeseries[i].eq(7).and(next.eq(10)).and(lc_timeseries[i-2].eq(10))
                                              , 10) // Wetland to Grassland in case the next two years were grassland
                                       .where(lc_timeseries[i].eq(4).and(next.eq(7)).and(lc_timeseries[i-2].eq(7))
                                              , 7) // Forest to Wetland in case the next two years were wetland
                                       .where(lc_timeseries[i].eq(2).and(next.eq(10)).and(lc_timeseries[i-2].eq(10))
                                              , 10) // Forest to grassland in case the next two years were grassland
                                       .where(lc_timeseries[i].eq(9).and(next.eq(10)).and(lc_timeseries[i-2].eq(10))
                                             , 10) // Shrubland to Grassland in case the next two years were grassland
  }
  
    if (i === 2) {
      lc_timeseries[i] = lc_timeseries[i].where(lc_timeseries[i].eq(previous)
                                                .and(lc_timeseries[i].eq(lc_timeseries[i+2]))
                                                .and(lc_timeseries[i].neq(lc_timeseries[i+3])), current);
    }

  // Export the harmonized land cover datasets to assets
  Export.image.toAsset({
    image: lc_timeseries[i].clip(county.geometry()).toByte(),
    description: ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_'+years[i]+'_'+VERSION_NO+'_harmonized',
    assetId: 'users/ocsgeospatial/Lesotho/'+ALGO.toLowerCase()+'_lesotho_s2_60_10bands_kfold_'+years[i]+'_'+VERSION_NO+'_harmonized',
    region: county.geometry(),
    crs: 'EPSG:4326',
    scale: 10,
    maxPixels:1e13,
    pyramidingPolicy: 'MODE'
    //skipEmptyTiles: true, 
    //fileFormat: 'GeoTIFF',
    //fileDimensions: [4096,4096],
    //formatOptions: {
    //  cloudOptimized: true
    //}
});

}

lc_timeseries_new = lc_timeseries.slice(1, -1);

// Plot the Harmonized Land Cover Series to compare with the non-harmonized one
Map.addLayer(ee.Image(lc_timeseries_new.slice(-1)), {palette: palette, min: 1, max: 14}, '2017 filtered')
Map.addLayer(ee.Image(lc_timeseries_new.slice(-2, -1)), {palette: palette, min: 1, max: 14}, '2018 filtered')
Map.addLayer(ee.Image(lc_timeseries_new.slice(-3, -2)), {palette: palette, min: 1, max: 14}, '2019 filtered')
Map.addLayer(ee.Image(lc_timeseries_new.slice(-4, -3)), {palette: palette, min: 1, max: 14}, '2020 filtered')
Map.addLayer(ee.Image(lc_timeseries_new.slice(-5, -4)), {palette: palette, min: 1, max: 14}, '2021 filtered')
